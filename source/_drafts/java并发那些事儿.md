---
title: java并发那些事儿
date: 2017-05-22 23:16:14
categories: 技术
tags: java并发
---



## 概述

项目中用到了双重检查锁定单例模式（DCL），同组的同学看到后给提交了新的merge request，去除了双重检查锁定，原因是DCL并不是安全的。从这个引子开始，我接触到了一系列并发相关的知识，并有了自己的理解，这里用文字整理出来，以巩固知识。先留下最初的问题：DCL为什么是不安全的，如何保证DCL的并发安全？接下去的内容会逐步解释这个问题。



## 并发不安全是怎么产生的？

现代计算机，为了优化计算性能，在底层实现上采用了高速缓存，每个CPU前都有一级或多级高速缓存，从而减少了CPU直接同主内存交互的开销。这样的策略在单线程的环境下是没有问题的，但是当多个线程同时对主内存中的一个地址进行读写操作时，问题就产生了。因为CPU的缓存机制，CPU往往不能读取到最新写入主内存的数据，从而产生不可预期的结果。暂且，可以将之称之为内存不可见问题。

除此之外，现在计算机还会对指令进行优化排序，避免一些指令访问内存资源的同时占用CPU时间。这一行为导致很难预测代码真正的执行顺序。同时，现代计算机往往为多核CPU架构，多核可并行处理多条指令，这也让指令的执行顺序难以预测。我将其归结为指令乱序问题。

复杂的物理环境已经让指令的执行情况扑所迷离，然而还有更让人抓狂的JAVA的运行时环境。JAVA的内存模型，为了提高线程执行效率，每个线程都有自己的工作内存，在线程开始执行时从主内存提取需要的数据做备份，在线程执行结束时再回写主内存。这同样会引发内存不可见问题。而且，JIT编译器也会对指令进行重排序操作（即生成的机器指令和字节码指令顺序不一致），仅仅保证重排序的结果和代码本身的应有结果在单线程环境下是保持一致的，即同样会引发指令乱序的问题。

在内存不可见和指令乱序的情况下，并发执行的两个线程只要同时依赖一个内存区域的数据，对这一个内存区域进行读写操作，那么即会产生并发不安全的现象。一个值，可能在A线程中看到的是a，但可能在B线程中看到的就是b。



## 在JAVA环境下如何保证并发安全？

好在JAVA为我们提供了办法，解决上面这些头疼的问题。

1. JAVA的目标是具备跨平台特性。然而不同的系统，不同的设备产商，在指令排序规则上都有所不同。为了屏蔽复杂的物理环境，JSR-1337制定了Java内存模型(Java Memory Model, JMM)，旨在提供一个统一的可参考的规范，屏蔽平台差异性。从Java 5开始，Java内存模型成为Java语言规范的一部分。Java内存模型规范的8条happens-before原则，虽然不能非常准确的描述实际微处理器等底层设备的工作情况，但是给开发者提供了开发的参考，可以视为Java程序一定会以happens-before原则处理指令排序。这样底层差异就被统一了。

- 程序次序法则：若在程序中，所有的动作B都出现在A之后，则线程中的每个动作A都happens-before于该线程中的每一个动作B。
- 监视器锁法则：对一个监视器锁的解锁 happens-before于每一个后续对同一监视器锁的加锁。
- volatile变量法则：对volatile域的写入操作happens-before于每一个后续对同一个域的读写操作。
- 线程启动法则：在一个线程里，对Thread.start的调用会happens-before于每个启动线程的动作。
- 线程终结法则：线程中的任何动作都happens-before于其他线程检测到这个线程已经终结、或者从Thread.join调用中成功返回，或Thread.isAlive返回false。
- 中断法则：一个线程调用另一个线程的interrupt happens-before于被中断的线程发现中断。
- 终结法则：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。
- 传递性：如果A happens-before于B，且B happens-before于C，则A happens-before于C



2. JAVA为程序开发人员提供了便捷的底层同步操作工具，开发人员可以在代码层级进行同步控制，以保证运行时环境能够按照预期的方式执行多线程操作。例如Synchronized修饰符可以保证内存可见，保证修饰代码转译的指令片段在同时被两个线程执行时，两个片段在执行时间上没有交集；volatile关键字，可以保证内存可见性，同时可以保证对volatile域的写入操作happens-before于每一个后续对同一个域的读写操作（happens-before原则）。这些便捷的同步工具，解决了JAVA运行时环境的内存不可见和指令重排序带来的并发安全问题。

   ​

## DCL为什么是不安全的？

我们解释一开始DCL的问题。先看一段DCL的代码

```java
    public class Test {

        private static Test a;

        private int num = 0;
        
        private Test(){
            num = 6;
        }

        public static Test getInstance() {

            if(a == null) {
                synchronized(Test.class) {
                    if(null == a) {
                        a = new Test();
                    }
                }
            }

            return a;
        }

        public int getNum(){
            return num;
        }

    }
```



我们可以通过happens-before法则分析一下这段代码。

假设由A,B两个线程同时执行了 `Test.getInstance()`  ，线程A优先获得共享锁。B线程在执行完`Test.getInstance()` 之后立刻执行了 `getNum()` 。我们用 “>” 号来表示 happens-before ，则：

* 由程序次序法则，线程A的监视器加锁操作 >  `num = 6`  > `a = new Test()` > A的监视器解锁操作。
* 由监视器法则，线程A的监视器解锁操作 > 线程B的监视器加锁操作。
* 由程序次序法则，线程B的监视器加锁操作 >  `if(null == a)` > `getNum()`。
* 由传递性，线程A的 `num = 6`  > 线程B的 `if(null == a)` > 线程B的`getNum()`。
* 即如果线程A和线程B都进入锁区，则线程A创建的Test对象的属性 num = 6 可以被线程B正常读取。

那为什么说DCL仍然是不安全的？问题出在`if(a == null)` 外层的这行if判断上，当线程A进入锁区，线程B未进入锁区的情况下，无法通过监视器法则确定线程A的`num = 6` 和线程B的  `getNum()`   具有happens-before关系，即有可能乱序执行。则线程B有可能获得 num = 0 的结果。

如何解决这个问题呢，我们给a属性加上volatile关键字，再分析一下看看。

* 由程序次序法则，线程A的 `num = 6`  >  `a = new Test()` 。
* 由程序次序法则，线程B的 `if(a == null)` > `getNum()`。
* volatile变量法则，线程A的  `a = new Test()`  > 线程B的`if(a == null)` 。
* 由传递性，线程A的 `num = 6`  > `a = new Test()`  > 线程B的 `if(null == a)` > `getNum()`。
* 即线程A创建的Test对象的属性 num = 6 可以被线程B正常读取。

所以，结论即是，我们可以通过DCL和volatile的搭配使用，来保证DCL的并发安全。

